{"name":"Pioc","tagline":"A Dependency Injection Container for node.js","body":"# pioc - A Dependency Injection Container for node.js\r\n\r\nSince you're already here, I suppose you know what Dependency Injection is. If not,\r\nplease take a look at [Martin Fowlers Article](http://www.martinfowler.com/articles/injection.html).\r\nDon't be afraid, this is a tool for Javascript, not Java, so you won't need to write\r\nXML or anything like that to configure **pioc**.\r\n\r\nThe short story is that **pioc** will allow you to write loosely coupled modules which enable you to easily switch specific implementations with something else (i.e. for tests or during natural growth of an application) without the mess that you'd normally have to work through.\r\n\r\n**pioc** is very smart about how and *when* to initialize your services. It supports **constructor injection**, **property injection**, static values and even **module inheritance** with all the parts that are needed to make it work.\r\n\r\nIf you were writing Java, **pioc** would remove the need for the \"new\" keyword in your vocabulary. For Javascript, it does the same but it also removes many function invocations, *require* statements and so on.\r\n\r\nWhether you're writing an **express.js** application or a website, **pioc** has the features you need to be more productive and it has an extensive test suite.\r\n\r\n## License\r\n\r\n**pioc** is *MIT* licensed.\r\n\r\n## Installation\r\n\r\n```\r\nnpm install --save pioc\r\n```\r\n\r\n## Example\r\n\r\nBefore I explain any details, let me give you an example of what can be done\r\nwith **pioc** and how it is used.\r\n\r\n```javascript\r\n// inside lib/db.js\r\nvar MongoClient = require('mongodb').MongoClient;\r\n// we can write modules that require dependencies by specifying\r\n// module.exports as a function\r\n// This one needs a Promise constructor and the configuration for our app\r\nmodule.exports = function(Promise, config) {\r\n    // you like Promises, don't you?\r\n    return Promise(function(resolve, reject) {\r\n        MongoClient.connect(config.db.url, function(err, db) {\r\n            if(err) return reject(err);\r\n            resolve(db);\r\n        });\r\n    });\r\n};\r\n```\r\n\r\n```javascript\r\n// inside config/development.json\r\n{\r\n    \"db\": {\r\n        \"url\": \"mongodb://localhost:27017/myproject\"\r\n    }\r\n}\r\n```\r\n\r\n```javascript\r\n// inside app.js\r\nvar pioc = require('pioc'),\r\n    // create a new module,\r\n    // by specifying __dirname, we can load services using\r\n    // node.js require relative to the app.js file\r\n    module = pioc.createModule(__dirname)\r\n        // not stricly necessary to bind bluebird as a Promise service,\r\n        // but this offers us the option to change to a different implementation\r\n        // easily\r\n        .value('Promise', require('bluebird'))\r\n        // load the config/development.json file and store it as a value service.\r\n        .loadValue('config/development')\r\n        // and now load our lib/db.js\r\n        .load('lib/db'),\r\n    // a module is not able to do anything on its own, most often, you'll\r\n    // want an injector or provider to go with it\r\n    injector = pioc.createInjector(module);\r\n\r\n// Now let's resolve some dependencies\r\ninjector.resolve(function(db) {\r\n    db.then(function(db) {\r\n        console.log('successfully connected to the database!');\r\n        db.close();\r\n    }).catch(function(err) {\r\n        console.log(err);\r\n    });\r\n});\r\n```\r\n\r\n## Changes\r\n\r\n### Version 1.1\r\n\r\n- **Provider#getAll(servicePrefix)**: Returns a list of all services that start with the given prefix\r\n- **Property injection**: Constructor functions and objects can use pioc.inject to specify properties that should be injected during the resolve process\r\n- **Object instantiation**: Services can now be constructors instead of just simple factory functions.\r\n- Undocumented Module#bind(serviceName).to(serviceDefinition) has been *removed*.\r\n- **Module#bind(obj), Module#value(obj), Module#factory(obj)**: Binds all services defined in the object to their property name.\r\n- **Module#has(serviceName)**: Returns `true`, if the service is defined in the module (or a parent module); `false`, otherwise.\r\n- Comments in function declarations are *ignored* (would've resulted in an error previously).\r\n\r\n## Structure\r\n\r\nIn **pioc**, a *Module* simply stores *service definitions* but it has nothing\r\nat all to do with how they're resolved or injected into other services.\r\n\r\nThe task of resolving a *service definition* is the responsibility of the\r\n*Provider*. The *Injector* we saw above is simply a convenient way\r\nto start an application. Instead of doing it the way I displayed above, you\r\ncould also get a *Provider* for the *Module* and ask it to resolve a\r\n*service definition* that acts as the starting point of your application.\r\n\r\nWhat that means is simple: If a *Module* is not responsible for resolving a\r\nservice, then you can create child modules, as well as more than one *Provider*\r\nand *Injector* from the same *Module* and each of them will provide their\r\nown instance of your service.\r\n\r\n## Inheritance\r\n\r\n*Module* and *Provider* can both create children. This allows you to create only\r\nthe amount of instances of a service that you really need. Let's have a look at it.\r\n\r\n```javascript\r\nvar pioc = require('pioc'),\r\n    // create a module and a child module\r\n    module = pioc.createModule(),\r\n    childModule = module.create(),\r\n    // create a provider and a child provider\r\n    provider = pioc.createProvider(module),\r\n    childProvider = provider.create(childModule);\r\n\r\n// now let's define some services\r\nmodule.value('message', 'Hello World')\r\n    .bind('write', function() {\r\n        return function(text) {\r\n            console.log(text);\r\n        };\r\n    })\r\n    .bind('greeting', function(message) {\r\n        return message + '!';\r\n    })\r\n    .bind('logger', function(greeting, write) {\r\n        return function() {\r\n            write(greeting);\r\n        };\r\n    });\r\n\r\n// override the definition of \"message\" for the child\r\nchildModule.value('message', 'Hello Universe');\r\n\r\n// get our services\r\nvar logWorld = provider.get('logger'),\r\n    logUniverse = childProvider.get('logger');\r\n\r\n// prints \"Hello World!\"\r\nlogWorld();\r\n\r\n// prints \"Hello Universe!\"\r\nlogUniverse();\r\n```\r\n\r\nSince a *Module* and a *Provider* can both create children and inheritance works\r\nas expected, we can create the same service with entirely different configurations\r\nas if it was nothing.\r\n\r\nHowever, since **pioc** always tries to limit the instances of a service to the\r\nminimum, our _write_ service is only instantiated once.\r\n\r\nIf you're application has modules that need to redefine some dependencies, you\r\ncan create a child module and a new *Provider* or *Injector* for the specifiy\r\nmodule and it'll receive the proper dependencies.\r\n\r\n## Available services in an *Injector*\r\n\r\nWhen using an *Injector*, you gain free access to a few useful services:\r\n\r\n* **$module**: A child of the current *Module*\r\n* **$provider**: The currently used *Provider*\r\n* **$injector**: The *Injector* instance\r\n* **$pioc**: The **pioc** object\r\n\r\nUsing these services, you can create sub modules like this:\r\n\r\n```javascript\r\ninjector.resolve(function($pioc, $module, $provider) {\r\n    $module.bind('message', 'Hi World');\r\n    var injector = $pioc.createInjector($module, $provider);\r\n    injector.resolve(function(logger) {\r\n        // prints \"Hi World!\" to console.log\r\n        logger();\r\n    });\r\n});\r\n```\r\n\r\nBy sharing an ancestoral *Provider* in you're sub module, you can be certain that\r\nonly those services are freshly instantiated which depend on modified services.\r\n\r\n## API Documentation\r\n\r\n### require('pioc')\r\n\r\n#### createModule([rootDirectory: String]): Module\r\nCreates a new *Module*. If a *rootDirectory* is specified, the new *Module*\r\nwill load all services relative to that directory.\r\n\r\n#### createProvider(module: Module): Provider\r\nCreates a new *Provider* for the given *Module*.\r\n\r\n#### createInjector(module: Module[, provider: Provider]): Injector\r\nCreates a new *Injector* for the given *Module*. The *Injector* will use\r\nthe a child of the given *Provider* or a new one.\r\n\r\n#### inject(serviceName: String): Object\r\nCreates an injectable annotation that signals pioc to inject the required service during the resolve process.\r\n\r\n*Example*\r\n\r\n```javascript\r\nvar inject = pioc.inject;\r\nmodule\r\n    .value('message', 'Hello World!')\r\n    .bind('foo', {\r\n        message: inject('message'),\r\n        sayHello: function() {\r\n            console.log(this.message);\r\n        }\r\n    });\r\nprovider.get('foo').sayHello(); // => Hello World!\r\n```\r\n\r\n#### inject(): Object\r\nCreates an injectable annotation that signals pioc to inject the required service during the resolve process.\r\nThe service name will be inferred through the property name.\r\n\r\n*Example*\r\n\r\n```javascript\r\nmodule\r\n    .value('message', 'Hello World!')\r\n    .bind('foo', {\r\n        message: pioc.inject(), // requires the service \"message\"\r\n        sayHello: function() {\r\n            console.log(this.message);\r\n        }\r\n    });\r\nprovider.get('foo').sayHello(); // => Hello World!\r\n```\r\n\r\n#### inject(target:Function|Object, ...serviceNames): target\r\nDefines injectable annotations for the given service name on the object or the prototype\r\nof the function and returns the given `target`.\r\n\r\n*Example*\r\n\r\n```javascript\r\nvar inject = pioc.inject;\r\nmodule\r\n    .value('message', 'Hello World!')\r\n    .bind('foo', inject({\r\n        sayHello: function() {\r\n            console.log(this.message);\r\n        }\r\n    }, 'message'));\r\nprovider.get('foo').sayHello(); // => Hello World!\r\n```\r\n\r\n#### inject(...serviceNames, target:Function|Object): target\r\nDefines injectable annotations for the given service name on the object or the prototype\r\nof the function and returns the given `target`.\r\n\r\n*Example*\r\n\r\n```javascript\r\nvar inject = pioc.inject;\r\nmodule\r\n    .value('message', 'Hello World!')\r\n    .bind('foo', inject('message', function() {\r\n        this.sayHello = function() {\r\n            console.log(this.message);\r\n        };\r\n    }));\r\nprovider.get('foo').sayHello(); // => Hello World!\r\n```\r\n\r\n### Injector\r\n\r\n#### resolve(service: Function|Array<String...,Function>): Any\r\nResolves the specified service and returns whatever the service returned.\r\n\r\nIf a dependency doesn't exist, it'll instead try to load all services with that prefix (see Provider#getAll).\r\n\r\n*Example*\r\n\r\n```javascript\r\nmodule\r\n    .value('config', { port: 3000 })\r\n    .bind('routes/auth', require('./app/modules/auth'))\r\n    .bind('routes/api', require('./app/modules/api'));\r\nvar app = injector.resolve(function(routes, config) {\r\n    var app = express();\r\n    routes.forEach(function(route) { app.use(routes); });\r\n    return app.listen(config.port);\r\n});\r\n```\r\n\r\n### Provider\r\n\r\n#### get(name: String): Any|Array<Any>\r\nReturns an instance of the specified service. If no service with the given name was found,\r\nan error will be thrown.\r\n\r\n**throws**: Error, if the specified *service* is not defined in the *module* or a parent of the *module* associated with the *Provider*.\r\n\r\n#### getAll(servicePrefix: String): Array<Any>\r\nReturns all services whose name starts with the given prefix.\r\n\r\n*Example*\r\n\r\n```javascript\r\nmodule\r\n    .bind('routes/auth', require('./app/modules/auth'))\r\n    .bind('routes/api', require('./app/modules/api'));\r\nvar routes = provider.getAll('routes/');\r\nvar app = express();\r\nroutes.forEach(function(route) { app.use(routes); });\r\napp.listen(3000);\r\n```\r\n\r\n#### create(module: Module): Provider\r\nReturns a new child of this *Provider* with the specified child *Module*.\r\n\r\n**throws**: Error, if the given *module* is not a child of the *module* of the\r\n*Provider* it is invoked for.\r\n\r\n### Module\r\n\r\n#### value(name: String, service: Any): Module\r\nBinds the specified _service_ to the given _name_. A service that is bound using\r\n*value* will resolved as is, i.e. no dependencies will be injected into it.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### value(serviceContainer: Object): Module\r\nFor each _service_ as _name_ in _serviceContainer_, it binds the specified _service_ to the given _name_.\r\nA service that is bound using *value* will resolved as is, i.e. no dependencies will be injected into it.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n*Example*\r\n\r\n```javascript\r\nmodule.value({\r\n    config: { port: 3000 },\r\n    db: { url: 'mongodb://...' }\r\n});\r\nprovider.get('config').port === 3000;\r\nprovider.get('db').url === 'mongodb://...';\r\n```\r\n\r\n#### bind(name: String, service: Any): Module\r\nBinds the specified _service_ to the given _name_. The service will be resolved\r\nwhen needed (i.e. lazy) and behaves like a singleton unless Inheritance requires\r\na new instance (i.e. dependencies have been reconfigured for a child module).\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### bind(serviceContainer: Object): Module\r\nFor each _service_ as _name_ in _serviceContainer_, it binds the specified _service_ to the given _name_. The service will be resolved\r\nwhen needed (i.e. lazy) and behaves like a singleton unless Inheritance requires\r\na new instance (i.e. dependencies have been reconfigured for a child module).\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### bindFactory(name: String, service: Any): Module\r\nBinds the specified _service_ to the given _name_. The service will be resolved\r\nwhen needed (i.e. lazy) and will be instantiated whenever the specified service is\r\nrequested. This is intended to be used for services that should never behave like\r\na singleton.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### bindFactory(serviceContainer: Object): Module\r\nFor each _service_ as _name_ in _serviceContainer_, it binds the specified _service_ to the given _name_. The service will be resolved\r\nwhen needed (i.e. lazy) and will be instantiated whenever the specified service is\r\nrequested. This is intended to be used for services that should never behave like\r\na singleton.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### loadValue([name: String, ]filename: String): Module\r\nLoads a service using require. The module.exports of the file will be bound as a\r\nvalue.\r\n\r\nIf *name* is specified, the service will be bound by that name, otherwise, the\r\nname of the service will be retrieved by using the last segment of the *filename*,\r\nwithout any file extensions.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### load([name: String, ]filename: String): Module\r\nLoads a service using require. The module.exports of the file will be bound to\r\nthis module.\r\n\r\nIf *name* is specified, the service will be bound by that name, otherwise, the\r\nname of the service will be retrieved by using the last segment of the *filename*,\r\nwithout any file extensions.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### loadFactory([name: String, ]filename: String): Module\r\nLoads a service using require. The module.exports of the file will be bound to\r\nthis module as a factory.\r\n\r\nIf *name* is specified, the service will be bound by that name, otherwise, the\r\nname of the service will be retrieved by using the last segment of the *filename*,\r\nwithout any file extensions.\r\n\r\nReturns the module to allow method chaining.\r\n\r\n#### has(name: String): Boolean\r\nReturns `true`, if the specified service is defined in this module or a parent module; `false`, otherwise.\r\n\r\n#### create(): Module\r\nReturns a new child of this *Module*.\r\n","google":"UA-56823995-1","note":"Don't delete this file! It's used internally to help with page regeneration."}